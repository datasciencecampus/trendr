##' Runs the Diffuse Kalman Filter (DFK).
##'
##' The state space form is
##' y(x)  =  Z(x)*alpha(x) + G*u(x)
##' alpha(x+1) = TT*alpha(x) + H*u(x)
##' the DKF is initialized with A0 and P0 (Q0=0).
##'
##' sigma.eps^2 is concentrated out
##'
##' @param x A vector with values of hyperparameters
##' @param y A vector with the values of the time series
##' 
##' @author Sonia Mazzi
##' @export
dfkLLMvard <- function(x, y) {
  sigma.eps <- 1
  sigma.gnu <- x[1]
  sigma.eta <- x[2]
  delta <- x[3]
  ll <- length(y)
  aux <- c(1, 1, 0, delta)
  TT <- matrix(aux, 2, 2, byrow = T)
  lTT <- nrow(TT)
  A <- cbind(diag(-1, lTT), rep(0, lTT))
  ncA0 <- ncol(A)
  QQ <- matrix(0, ncA0, ncA0)
  DD <- rep(0, ll)
  EE <- matrix(0, 1, (ncA0*ll))
  AA <- matrix(rep(0, ncA0 * lTT * (ll + 1)), lTT, (ncA0 * (ll + 1)))
  AA[,(1:ncA0)] <- A
  PP <- matrix(rep(0, (lTT * lTT * (ll + 1))), lTT, (lTT * (ll + 1)))
  KK <- matrix(rep(0, (lTT * ll)), lTT, ll)
  elem <- c((sigma.gnu^2), 0, 0, (sigma.eta^2))
  HHt <- matrix(elem, lTT, lTT, byrow = T)
  P <- matrix(0 ,lTT, lTT)
  PP[ ,(1 : lTT)] <- P
  ee <- rep(0, ll)
  mse.ee <- rep(0, ll)
  GGt <- sigma.eps^2
  Z <- matrix(c(1, 0), 1, lTT)
  ZZ <- matrix(0, ll, 2)
  for (i in 1:ll){
    ZZ[i,] <- Z
    aux2 <- matrix(c(rep(0, (ncA0 - 1)), y[i]), 1, ncA0)
    E <- aux2 - Z %*% A
    EE[,((i-1) * ncA0 + 1) : (i * ncA0)] <- E
    EEgam <- matrix(E[, (1 : lTT)], 1, lTT)
    D <- Z %*% P %*% t(Z) + GGt
    DD[i] <- D
    Dinv <- 1/D
    K <- TT %*% P %*% t(Z) %*% Dinv
    KK[,i] <- K
    A <- TT %*% A + K %*% E
    AA[, ((i * ncA0 + 1) : ((i + 1) * ncA0))] <- A
    L <- TT - K %*% Z
    P <- L %*% P %*% t(TT) + HHt
    PP[, ((i * lTT + 1) : ((i + 1) * lTT))] <- P
    if (i > 2){ 
      SS <- QQ[(1:lTT), (1:lTT)]
      SSinv <- solve(SS)
      ss <- QQ[(1:lTT), ((lTT+1) : ncA0)]
      gamma <- SSinv %*% ss
      aux <- matrix(c(-gamma, 1), ncA0, 1)
      ee[i] <- E %*% aux
      mse.ee[i] <- EEgam %*% SSinv %*% t(EEgam)
    } 
    QQ <- QQ + t(E) %*% Dinv %*% E}
    Alast <- A
    Plast <- P
    SS <- QQ[(1:lTT), (1:lTT)]
    qqq <- as.matrix(QQ[((lTT+1) : ncA0), ((lTT+1) : ncA0)])
    ss <- QQ[(1:lTT), ((lTT+1) : ncA0)]
    Sinv <- solve(SS)
    gamma.est <- Sinv %*% ss
    sigma2.est <- (qqq - t(ss) %*% Sinv %*% ss)/ll
    sigma2.est <- as.numeric(sigma2.est)
    mse.gamma.est <- sigma2.est*Sinv
    mse.ee <- sigma2.est * (DD + mse.ee)
    sigmatilde2 <- (ll / (ll - ncA0 + 1)) * sigma2.est
    loglik <- (-0.5) * ((ll - ncA0 + 1) * (1 + log(sigmatilde2)) + sum(log(abs(DD))))
    ee.std <- ee/sqrt(mse.ee)
    list(gamma.est = gamma.est, mse.gamma = mse.gamma.est, loglik = loglik, ncA0 = ncA0, ll = ll, delta = delta,
    D = DD, E = EE, Z = ZZ, A = AA, P = PP, K = KK, TT = TT, y = y, ee = ee, mse.ee = mse.ee, ee.std = ee.std, 
    Alast = Alast, 
    Plast = Plast,
    sigma2 = sigma2.est, 
    sigma.eps2 = sigma2.est * sigma.eps^2,
    sigma.gnu2 = sigma2.est * sigma.gnu^2,
    sigma.eta2 = sigma2.est * sigma.eta^2,
    sigma.eps = sqrt(sigma2.est * sigma.eps^2),
    sigma.gnu = sqrt(sigma2.est * sigma.gnu^2),
    sigma.eta = sqrt(sigma2.est * sigma.eta^2))
    }
